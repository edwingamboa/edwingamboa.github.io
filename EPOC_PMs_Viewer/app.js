!function(e){var n=window.webpackHotUpdate;window.webpackHotUpdate=function(e,t){!function(e,n){if(!E[e]||!T[e])return;for(var t in T[e]=!1,n)Object.prototype.hasOwnProperty.call(n,t)&&(f[t]=n[t]);0==--v&&0===h&&L()}(e,t),n&&n(e,t)};var t,r=!0,i="975970eb74a89b1993ad",s=1e4,a={},o=[],d=[];function c(e){var n=x[e];if(!n)return D;var r=function(r){return n.hot.active?(x[r]?-1===x[r].parents.indexOf(e)&&x[r].parents.push(e):(o=[e],t=r),-1===n.children.indexOf(r)&&n.children.push(r)):(console.warn("[HMR] unexpected require("+r+") from disposed module "+e),o=[]),D(r)},i=function(e){return{configurable:!0,enumerable:!0,get:function(){return D[e]},set:function(n){D[e]=n}}};for(var s in D)Object.prototype.hasOwnProperty.call(D,s)&&"e"!==s&&"t"!==s&&Object.defineProperty(r,s,i(s));return r.e=function(e){return"ready"===u&&p("prepare"),h++,D.e(e).then(n,function(e){throw n(),e});function n(){h--,"prepare"===u&&(I[e]||S(e),0===h&&0===v&&L())}},r.t=function(e,n){return 1&n&&(e=r(e)),D.t(e,-2&n)},r}var l=[],u="idle";function p(e){u=e;for(var n=0;n<l.length;n++)l[n].call(null,e)}var m,f,g,v=0,h=0,I={},T={},E={};function C(e){return+e+""===e?+e:e}function _(e){if("idle"!==u)throw new Error("check() is only allowed in idle status");return r=e,p("check"),function(e){return e=e||1e4,new Promise(function(n,t){if("undefined"==typeof XMLHttpRequest)return t(new Error("No browser support"));try{var r=new XMLHttpRequest,s=D.p+""+i+".hot-update.json";r.open("GET",s,!0),r.timeout=e,r.send(null)}catch(e){return t(e)}r.onreadystatechange=function(){if(4===r.readyState)if(0===r.status)t(new Error("Manifest request to "+s+" timed out."));else if(404===r.status)n();else if(200!==r.status&&304!==r.status)t(new Error("Manifest request to "+s+" failed."));else{try{var e=JSON.parse(r.responseText)}catch(e){return void t(e)}n(e)}}})}(s).then(function(e){if(!e)return p("idle"),null;T={},I={},E=e.c,g=e.h,p("prepare");var n=new Promise(function(e,n){m={resolve:e,reject:n}});f={};return S(0),"prepare"===u&&0===h&&0===v&&L(),n})}function S(e){E[e]?(T[e]=!0,v++,function(e){var n=document.createElement("script");n.charset="utf-8",n.src=D.p+""+e+"."+i+".hot-update.js",document.head.appendChild(n)}(e)):I[e]=!0}function L(){p("ready");var e=m;if(m=null,e)if(r)Promise.resolve().then(function(){return b(r)}).then(function(n){e.resolve(n)},function(n){e.reject(n)});else{var n=[];for(var t in f)Object.prototype.hasOwnProperty.call(f,t)&&n.push(C(t));e.resolve(n)}}function b(n){if("ready"!==u)throw new Error("apply() is only allowed in ready status");var t,r,s,d,c;function l(e){for(var n=[e],t={},r=n.slice().map(function(e){return{chain:[e],id:e}});r.length>0;){var i=r.pop(),s=i.id,a=i.chain;if((d=x[s])&&!d.hot._selfAccepted){if(d.hot._selfDeclined)return{type:"self-declined",chain:a,moduleId:s};if(d.hot._main)return{type:"unaccepted",chain:a,moduleId:s};for(var o=0;o<d.parents.length;o++){var c=d.parents[o],l=x[c];if(l){if(l.hot._declinedDependencies[s])return{type:"declined",chain:a.concat([c]),moduleId:s,parentId:c};-1===n.indexOf(c)&&(l.hot._acceptedDependencies[s]?(t[c]||(t[c]=[]),m(t[c],[s])):(delete t[c],n.push(c),r.push({chain:a.concat([c]),id:c})))}}}}return{type:"accepted",moduleId:e,outdatedModules:n,outdatedDependencies:t}}function m(e,n){for(var t=0;t<n.length;t++){var r=n[t];-1===e.indexOf(r)&&e.push(r)}}n=n||{};var v={},h=[],I={},T=function(){console.warn("[HMR] unexpected require("+S.moduleId+") to disposed module")};for(var _ in f)if(Object.prototype.hasOwnProperty.call(f,_)){var S;c=C(_);var L=!1,b=!1,A=!1,O="";switch((S=f[_]?l(c):{type:"disposed",moduleId:_}).chain&&(O="\nUpdate propagation: "+S.chain.join(" -> ")),S.type){case"self-declined":n.onDeclined&&n.onDeclined(S),n.ignoreDeclined||(L=new Error("Aborted because of self decline: "+S.moduleId+O));break;case"declined":n.onDeclined&&n.onDeclined(S),n.ignoreDeclined||(L=new Error("Aborted because of declined dependency: "+S.moduleId+" in "+S.parentId+O));break;case"unaccepted":n.onUnaccepted&&n.onUnaccepted(S),n.ignoreUnaccepted||(L=new Error("Aborted because "+c+" is not accepted"+O));break;case"accepted":n.onAccepted&&n.onAccepted(S),b=!0;break;case"disposed":n.onDisposed&&n.onDisposed(S),A=!0;break;default:throw new Error("Unexception type "+S.type)}if(L)return p("abort"),Promise.reject(L);if(b)for(c in I[c]=f[c],m(h,S.outdatedModules),S.outdatedDependencies)Object.prototype.hasOwnProperty.call(S.outdatedDependencies,c)&&(v[c]||(v[c]=[]),m(v[c],S.outdatedDependencies[c]));A&&(m(h,[S.moduleId]),I[c]=T)}var y,R=[];for(r=0;r<h.length;r++)c=h[r],x[c]&&x[c].hot._selfAccepted&&R.push({module:c,errorHandler:x[c].hot._selfAccepted});p("dispose"),Object.keys(E).forEach(function(e){!1===E[e]&&function(e){delete installedChunks[e]}(e)});for(var w,P,M=h.slice();M.length>0;)if(c=M.pop(),d=x[c]){var N={},F=d.hot._disposeHandlers;for(s=0;s<F.length;s++)(t=F[s])(N);for(a[c]=N,d.hot.active=!1,delete x[c],delete v[c],s=0;s<d.children.length;s++){var j=x[d.children[s]];j&&((y=j.parents.indexOf(c))>=0&&j.parents.splice(y,1))}}for(c in v)if(Object.prototype.hasOwnProperty.call(v,c)&&(d=x[c]))for(P=v[c],s=0;s<P.length;s++)w=P[s],(y=d.children.indexOf(w))>=0&&d.children.splice(y,1);for(c in p("apply"),i=g,I)Object.prototype.hasOwnProperty.call(I,c)&&(e[c]=I[c]);var k=null;for(c in v)if(Object.prototype.hasOwnProperty.call(v,c)&&(d=x[c])){P=v[c];var U=[];for(r=0;r<P.length;r++)if(w=P[r],t=d.hot._acceptedDependencies[w]){if(-1!==U.indexOf(t))continue;U.push(t)}for(r=0;r<U.length;r++){t=U[r];try{t(P)}catch(e){n.onErrored&&n.onErrored({type:"accept-errored",moduleId:c,dependencyId:P[r],error:e}),n.ignoreErrored||k||(k=e)}}}for(r=0;r<R.length;r++){var V=R[r];c=V.module,o=[c];try{D(c)}catch(e){if("function"==typeof V.errorHandler)try{V.errorHandler(e)}catch(t){n.onErrored&&n.onErrored({type:"self-accept-error-handler-errored",moduleId:c,error:t,originalError:e}),n.ignoreErrored||k||(k=t),k||(k=e)}else n.onErrored&&n.onErrored({type:"self-accept-errored",moduleId:c,error:e}),n.ignoreErrored||k||(k=e)}}return k?(p("fail"),Promise.reject(k)):(p("idle"),new Promise(function(e){e(h)}))}var x={};function D(n){if(x[n])return x[n].exports;var r=x[n]={i:n,l:!1,exports:{},hot:function(e){var n={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:t!==e,active:!0,accept:function(e,t){if(void 0===e)n._selfAccepted=!0;else if("function"==typeof e)n._selfAccepted=e;else if("object"==typeof e)for(var r=0;r<e.length;r++)n._acceptedDependencies[e[r]]=t||function(){};else n._acceptedDependencies[e]=t||function(){}},decline:function(e){if(void 0===e)n._selfDeclined=!0;else if("object"==typeof e)for(var t=0;t<e.length;t++)n._declinedDependencies[e[t]]=!0;else n._declinedDependencies[e]=!0},dispose:function(e){n._disposeHandlers.push(e)},addDisposeHandler:function(e){n._disposeHandlers.push(e)},removeDisposeHandler:function(e){var t=n._disposeHandlers.indexOf(e);t>=0&&n._disposeHandlers.splice(t,1)},check:_,apply:b,status:function(e){if(!e)return u;l.push(e)},addStatusHandler:function(e){l.push(e)},removeStatusHandler:function(e){var n=l.indexOf(e);n>=0&&l.splice(n,1)},data:a[e]};return t=void 0,n}(n),parents:(d=o,o=[],d),children:[]};return e[n].call(r.exports,r,r.exports,c(n)),r.l=!0,r.exports}D.m=e,D.c=x,D.d=function(e,n,t){D.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},D.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},D.t=function(e,n){if(1&n&&(e=D(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(D.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)D.d(t,r,function(n){return e[n]}.bind(null,r));return t},D.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return D.d(n,"a",n),n},D.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},D.p="",D.h=function(){return i},c("./src/scripts/index.js")(D.s="./src/scripts/index.js")}({"./node_modules/raw-loader/index.js!./src/scripts/index.js":function(e,n){e.exports="/* globals FileReader, axios, c3, d3, ss */\n(function () {\n  const EPOC_MEASURES_CONTAINER_ID = 'measuresViewer';\n  const TRENDS_VIEWER_CONTAINER_ID = 'trendsViewer';\n  const PM_FILE_INPUT_ID = 'pmFileUrl';\n  const UT_FILE_INPUT_ID = 'userTraceFileUrl';\n  const LOADED_FILES_TEXT_ID = 'loadedFilesText';\n  const TREND_CHART_R_BTNS_DIV_ID = 'trendChartPmRBtnsDiv';\n  const DEFAULT_TREND_CHART_PM_ID = 'SCA_ENG';\n  const TOLERANCE_TIME_DIV_ID = 'toleranceElapTimeEvents';\n  const MAIN_CONTENT_DIV_ID = 'mainContent';\n  const PROGRESS_SPINNER_ID = 'progressSpinner';\n  const DEFAULT_SEGMENT_DISTANCE = 50;\n  const traceLogsInfo = new Map([\n    ['sessionId', { initCol: 0 }],\n    ['testerNumber', { initCol: 1 }],\n    ['timestamp', { initCol: 2 }],\n    ['msElapsedSinceLastEvent', { initCol: 3 }],\n    ['action', { initCol: 4 }],\n    ['actionD1', {\n      initCol: 5,\n      values: {\n        link: [\n          'Link_Orientierung_xpage',\n          'Link_Theorie_xpage',\n          'Link_Grundprinzip_xpage',\n          'Link_Berechnung_xpage',\n          'Link_Raue_Oberfl√§chen_xpage',\n          'Link_Anwendung_xpage',\n          'Link_FAQ_xpage',\n          'Link_Zusammenfassung_xpage',\n          'Link_Wiederholungsfragen_xpage',\n          'Link_Quellen_xpage'\n        ]\n      }\n    }],\n    ['actionD2', { initCol: 6 }],\n    ['actionD3', { initCol: 7 }]\n  ]);\n  const pmLogsInfo = new Map([\n    ['TimeStamp', { initCol: 0, verbose: 'Time Stamp' }],\n    ['SCA_ENG', { initCol: 1, verbose: 'Engagement' }],\n    ['SCA_VAL', { initCol: 6, verbose: 'Interest' }],\n    ['SCA_MED', { initCol: 11, verbose: 'Relaxation' }],\n    ['SCA_FRU', { initCol: 16, verbose: 'Stress' }],\n    ['SCA_FOC', { initCol: 21, verbose: 'Focus' }],\n    ['SCA_EXC', { initCol: 26, verbose: 'Excitement' }],\n    ['SCA_LEX', { initCol: 31, verbose: 'Long-term excitement' }],\n    ['pmIds', ['SCA_ENG', 'SCA_VAL', 'SCA_MED', 'SCA_FRU', 'SCA_FOC', 'SCA_EXC', 'SCA_LEX']]\n  ]);\n  const epocEventsData = {\n    '1': 'Eyes opened start',\n    '2': 'Eyes opened end',\n    '3': 'Eyes closed start',\n    '4': 'Eyes closed end',\n    '22': 'Kapitelwechsel',\n    '23': 'Einsch√§tzung',\n    '24': 'Bewegung',\n    '25': 'St√∂rger√§usche',\n    '26': 'Formel',\n    '27': 'Begriffe',\n    '28': 'Game/Quiz',\n    '29': 'Fragebogen',\n    '30': 'Texteingabe'\n  };\n\n  const userTraceActionsIds = {\n    booklet_switch: 1,\n    link: 2,\n    navigate: 3,\n    user_rating: 4\n  };\n\n  var pmFileInput = document.querySelector('#' + PM_FILE_INPUT_ID);\n  var userTraceFileInput = document.querySelector('#' + UT_FILE_INPUT_ID);\n  var loadedFilesTextElement = document.querySelector('#' + LOADED_FILES_TEXT_ID);\n  var pmCsvRequest;\n  var userTraceCsvRequest;\n  var pmMeasures;\n  var segments;\n  var userTraceLogs;\n  var trendsChart;\n  var firstRun = true;\n\n  pmFileInput.addEventListener('change', function (e) {\n    handleFileLoading(e.target.files[0], 'pm');\n  });\n\n  userTraceFileInput.addEventListener('change', function (e) {\n    handleFileLoading(e.target.files[0], 'ut');\n  });\n\n  function run (requests) {\n    Promise.all(requests)\n      .then(function (responses) {\n        pmMeasures = extractScaPerformanceMeasuresFromCSV(responses[0].data);\n        userTraceLogs = responses[1].data;\n        var userTraceRegions = parseUserTraceAsGridLines(extractUserTraceEvents(userTraceLogs));\n\n        addChart(\n          pmMeasures,\n          EPOC_MEASURES_CONTAINER_ID,\n          userTraceRegions,\n          addDetailsToUserTraceGridLines\n        );\n\n        updateTrendSegments();\n\n        var relativeChangeValsAndEvents = calculateTrendDataOfPm(pmMeasures, segments);\n        var eventsOfInterestGridLines = parseUserTraceAsGridLines(segments);\n        trendsChart = addChart(\n          relativeChangeValsAndEvents,\n          TRENDS_VIEWER_CONTAINER_ID,\n          eventsOfInterestGridLines,\n          addDetailsToUserTraceGridLines\n        );\n        resetFileChoosers();\n        updateLoadedFilesText(responses[0].filename + '; ' + responses[1].filename);\n        if (firstRun) {\n          appendRBtnsForTrendChart();\n          appendElapTimeInputForTrendChart();\n          firstRun = false;\n        }\n        switchToMainContent();\n      })\n      .catch(function (error) {\n        console.error(error);\n      });\n  }\n\n  function switchToMainContent () {\n    var mainContentDiv = document.querySelector('#' + MAIN_CONTENT_DIV_ID);\n    mainContentDiv.style.display = 'block';\n    var progressSpinner = document.querySelector('#' + PROGRESS_SPINNER_ID);\n    progressSpinner.style.display = 'none';\n  }\n\n  function switchToProgressSpinner () {\n    var mainContentDiv = document.querySelector('#' + MAIN_CONTENT_DIV_ID);\n    mainContentDiv.style.display = 'none';\n    var progressSpinner = document.querySelector('#' + PROGRESS_SPINNER_ID);\n    progressSpinner.style.display = 'block';\n  }\n\n  function handleFileLoading (file, id) {\n    if (id === 'pm') {\n      pmCsvRequest = readSingleFile(file);\n    } else {\n      userTraceCsvRequest = readSingleFile(file);\n    }\n    if (pmCsvRequest && userTraceCsvRequest) {\n      disableFileChoosers();\n      switchToProgressSpinner();\n      run([pmCsvRequest, userTraceCsvRequest]);\n    }\n  }\n\n  function readSingleFile (file) {\n    return new Promise(function (resolve, reject) {\n      if (!file) {\n        reject(new Error('Invalid file url'));\n      }\n      var reader = new FileReader();\n      reader.onload = function (e) {\n        resolve({\n          data: e.target.result,\n          filename: file.name\n        });\n      };\n      reader.readAsText(file);\n    });\n  }\n\n  function disableFileChoosers () {\n    pmFileInput.setAttribute('disabled', true);\n    userTraceFileInput.setAttribute('disabled', true);\n    loadedFilesTextElement.innerHTML = '';\n  }\n\n  function resetFileChoosers () {\n    pmFileInput.removeAttribute('disabled');\n    userTraceFileInput.removeAttribute('disabled');\n    pmFileInput.value = '';\n    userTraceFileInput.value = '';\n    pmCsvRequest = undefined;\n    userTraceCsvRequest = undefined;\n    updateLoadedFilesText('');\n  }\n\n  function updateLoadedFilesText (text) {\n    loadedFilesTextElement.innerHTML = text;\n  }\n\n  function changeDataOfTrendChart (pmId, onloaded) {\n    pmId = pmId || DEFAULT_TREND_CHART_PM_ID;\n    var relativeChangeValsAndEvents = calculateTrendDataOfPm(pmMeasures, segments, pmId);\n    var loadData = {\n      rows: relativeChangeValsAndEvents,\n      x: 'TimeStamp',\n      unload: []\n    };\n    if (onloaded) {\n      loadData.done = onloaded;\n    }\n    trendsChart.load(loadData);\n  }\n\n  function requestCsv (url) { // eslint-disable-line no-unused-vars\n    return axios.request({\n      url: url,\n      responseType: 'text'\n    });\n  }\n\n  function addChart (data, containerId, eventsMarks, onrendered, types) {\n    var chartProperties = {\n      data: {\n        rows: data,\n        x: 'TimeStamp'\n      },\n      axis: {\n        x: {\n          type: 'timeseries',\n          tick: {\n            format: function (x) {\n              return x.toLocaleString('de-DE');\n            }\n          }\n        }\n      },\n      bindto: '#' + containerId,\n      zoom: {\n        enabled: true\n      }\n    };\n    if (eventsMarks) {\n      chartProperties.grid = {\n        x: {\n          lines: eventsMarks\n        }\n      };\n    };\n    if (onrendered) {\n      chartProperties.onrendered = onrendered;\n    }\n    if (types) {\n      chartProperties.data = data;\n    }\n    return c3.generate(chartProperties);\n  }\n\n  function parseEventsAsRegionObjects (regionsAsCsv) { // eslint-disable-line no-unused-vars\n    var events = extractRegionsOfInterest(regionsAsCsv);\n    function getLineObject (event) {\n      return {\n        text: epocEventsData.hasOwnProperty(event.id) ? epocEventsData[event.id] : '',\n        value: event.time,\n        class: 'epoc-events-grid-lines' + event.id,\n        position: 'start'\n      };\n    }\n    return buildGridLinesList(events, getLineObject);\n  }\n\n  function extractRegionsOfInterest (csv) {\n    var dataRows = [];\n    getLinesOfCSV(csv).forEach(function (line, index) {\n      if (line !== '' && index > 0) {\n        const MARKER_COLUMN_INDEX = 19;\n        const NO_EVENT_ID = 0;\n        var columns = getColumnsOfACsvLine(line);\n        var eventId = columns[MARKER_COLUMN_INDEX];\n        if (eventId !== NO_EVENT_ID) {\n          columns.splice(0, MARKER_COLUMN_INDEX);\n          columns.splice(1, 4); // Remove unneeded left columns\n          columns.splice(4); // Remove unneeded right columns\n          dataRows.push({\n            id: parseInt(columns[0]),\n            time: dateBasedOnTimeStampMs(columns[1])\n          });\n        }\n      }\n    });\n    return dataRows;\n  }\n\n  function extractScaPerformanceMeasuresFromCSV (csv, desiredPms) {\n    var dataRows = [];\n    desiredPms = desiredPms || pmLogsInfo.get('pmIds');\n    getLinesOfCSV(csv).forEach(function (line, i) {\n      if (line !== '') {\n        var columns = getColumnsOfACsvLine(line);\n        var newColumns = [];\n        if (i > 0) {\n          newColumns.push(\n            dateBasedOnTimeStampMs(columns[pmLogsInfo.get('TimeStamp').initCol])\n          );\n          desiredPms.forEach(function (pm) {\n            newColumns.push(columns[pmLogsInfo.get(pm).initCol]);\n            pmLogsInfo.get(pm).newCol = newColumns.length - 1;\n          });\n        } else {\n          newColumns.push('TimeStamp');\n          desiredPms.forEach(function (pm) {\n            newColumns.push(pm + ' ' + pmLogsInfo.get(pm).verbose);\n          });\n        }\n        dataRows.push(newColumns);\n      }\n    });\n    return dataRows;\n  }\n\n  function extractUserTraceEvents (csv) {\n    var dataRows = [];\n    getLinesOfCSV(csv).forEach(function (line, index) {\n      if (line !== '' && index > 0) {\n        var columns = getColumnsOfACsvLine(line, ';');\n        dataRows.push({\n          time: new Date(columns[traceLogsInfo.get('timestamp').initCol]),\n          action: columns[traceLogsInfo.get('action').initCol],\n          details: columns.slice(traceLogsInfo.get('action').initCol).join(' ')\n        });\n      }\n    });\n    return dataRows;\n  }\n\n  function extractSegmentsFromTraceEvents (\n    csv, eventsOfInterest, columnOfTime, columnOfEvent, minElapsedSeconds\n  ) {\n    var segments = [];\n    var lastSegmentInitTime;\n    var lastSegmentAction;\n    var currentSegmentInitTime;\n    getLinesOfCSV(csv).forEach(function (line, index) {\n      if (line !== '' && index > 0) {\n        var columns = getColumnsOfACsvLine(line, ';');\n        if (eventsOfInterest.indexOf(columns[columnOfEvent]) > -1) {\n          currentSegmentInitTime = new Date(columns[columnOfTime]);\n          if (!lastSegmentInitTime) {\n            lastSegmentInitTime = currentSegmentInitTime;\n            lastSegmentAction = columns[columnOfEvent];\n          }\n          if (lastSegmentInitTime &&\n            elapsedSeconds(lastSegmentInitTime, currentSegmentInitTime) >= minElapsedSeconds) {\n            segments.push({\n              time: lastSegmentInitTime,\n              finishTime: currentSegmentInitTime,\n              action: lastSegmentAction,\n              details: lastSegmentAction + ': ' + extractTimeHHMMSS(lastSegmentInitTime) + ' - ' + extractTimeHHMMSS(currentSegmentInitTime)\n            });\n            lastSegmentInitTime = currentSegmentInitTime;\n            lastSegmentAction = columns[columnOfEvent];\n          };\n        }\n      }\n    });\n    return segments;\n  }\n\n  function extractTimeHHMMSS (date) {\n    return date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();\n  }\n\n  function parseUserTraceAsGridLines (userTraces) {\n    function getLineObject (userTrace) {\n      return {\n        text: userTrace.action,\n        details: userTrace.details,\n        value: userTrace.time,\n        class: 'user-trace-grid-lines' + ' ' + (userTraceActionsIds.hasOwnProperty(userTrace.action)\n          ? userTraceActionsIds[userTrace.action] : '')\n      };\n    }\n    return buildGridLinesList(userTraces, getLineObject);\n  }\n\n  function buildGridLinesList (dataList, getLineObject) {\n    var linesList = [];\n    dataList.forEach(function (lineData) {\n      linesList.push(getLineObject(lineData));\n    });\n    return linesList;\n  }\n\n  function getLinesOfCSV (csv) {\n    return csv.split('\\n');\n  }\n\n  function getColumnsOfACsvLine (line, separator) {\n    return line.split(separator || ',');\n  }\n\n  function dateBasedOnTimeStampMs (timestamp) {\n    return new Date(parseFloat(timestamp) * 1000);\n  }\n\n  function addDetailsToUserTraceGridLines () {\n    var gridLines = d3.selectAll('.user-trace-grid-lines text');\n    gridLines.each(function (d) {\n      if (d.details) {\n        var title = d3.select(this).select('title');\n        if (title.empty()) {\n          title = gridLines.append('title');\n        }\n        title.text(function (d) {\n          return d.details;\n        });\n      }\n    });\n  }\n\n  function calculateTrendDataOfPm (pmList, segments, pmId) {\n    pmId = pmId || 'SCA_ENG';\n    const timeColumnIndex = pmLogsInfo.get('TimeStamp').initCol;\n    const columnIndex = pmLogsInfo.get(pmId).newCol || pmLogsInfo.get(pmId).initCol;\n\n    var initialPmVal = pmList[1][columnIndex];\n    var currentPmVal;\n    var currentTime;\n    var relEngChangeVals = [];\n\n    pmList.slice(1).forEach(function (pm) {\n      currentTime = pm[timeColumnIndex];\n      currentPmVal = pm[columnIndex];\n      relEngChangeVals.push([\n        currentTime.getTime(),\n        parseFloat(relativePmChange(currentPmVal, initialPmVal))\n      ]);\n    });\n\n    var segmentsWithIndexes = addIndexesToSegments(segments, pmList.slice(1), timeColumnIndex);\n    segmentsWithIndexes.forEach(function (segment) {\n      if (segment.hasOwnProperty('initIndex')) {\n        addTrendPoints(relEngChangeVals, segment.initIndex, segment.finishIndex || relEngChangeVals.length - 1);\n      }\n    });\n    return [['TimeStamp', 'Relative Change', 'Trend']].concat(relEngChangeVals);\n  }\n\n  function addIndexesToSegments (segments, pmList, timeColumnIndex) {\n    var pmListIndex = 0;\n    segments.map(function (segment, i) {\n      while (pmListIndex < pmList.length &&\n        segment.time > pmList[pmListIndex][timeColumnIndex]) {\n        pmListIndex++;\n      }\n      if (pmListIndex < pmList.length) {\n        segment.initIndex = pmListIndex;\n        if (i > 0) {\n          segments[i - 1].finishIndex = pmListIndex - 1;\n        }\n      }\n      return segment;\n    });\n    return segments;\n  }\n\n  function addTrendPoints (data, segmentInitIndex, segmentFinalIndex) {\n    var f = ss.linearRegressionLine(ss.linearRegression(data.slice(segmentInitIndex, segmentFinalIndex + 1)));\n    data[segmentInitIndex][2] = f(data[segmentInitIndex][0]);\n    data[segmentFinalIndex][2] = f(data[segmentFinalIndex][0]);\n  }\n\n  function elapsedSeconds (initTime, finishTime) {\n    return Math.round(Math.abs(finishTime.getTime() - initTime.getTime()) / 1000);\n  }\n\n  function elapsedMinutes (initTime, finishTime) { // eslint-disable-line no-unused-vars\n    return elapsedSeconds(initTime, finishTime) / 60;\n  }\n\n  function relativePmChange (currentPm, initialPm) {\n    return (currentPm - initialPm) / initialPm;\n  }\n\n  function appendRBtnsForTrendChart () {\n    pmLogsInfo.get('pmIds').forEach(function (pmId) {\n      var pmInput = createInputElement(pmId, 'trendChartPM', pmId === DEFAULT_TREND_CHART_PM_ID);\n      var labelText = pmId + ' ' + pmLogsInfo.get(pmId).verbose;\n      var pmLabel = createLabelElement(pmId, labelText, 'form-check-label');\n      var trendChartRBtnsDiv = document.querySelector('#' + TREND_CHART_R_BTNS_DIV_ID);\n      var inputGroupContainer = document.createElement('div');\n      inputGroupContainer.setAttribute('class', 'form-check form-check-inline');\n      inputGroupContainer.appendChild(pmInput);\n      inputGroupContainer.appendChild(pmLabel);\n      trendChartRBtnsDiv.appendChild(inputGroupContainer);\n    });\n\n    function createInputElement (id, name, checked) {\n      var inputEl = document.createElement('input');\n      inputEl.setAttribute('id', id);\n      inputEl.setAttribute('value', id);\n      inputEl.setAttribute('type', 'radio');\n      inputEl.setAttribute('name', name);\n      inputEl.setAttribute('class', 'form-check-input');\n      if (checked) {\n        inputEl.setAttribute('checked', checked);\n      }\n      inputEl.addEventListener('change', function (e) {\n        changeDataOfTrendChart(this.value);\n      });\n      return inputEl;\n    }\n  }\n\n  function appendElapTimeInputForTrendChart () {\n    var elapTimeInputId = 'elapseTimeInput';\n    var elapTimeInput = createNumberInput();\n    var elapTimeLabel = createLabelElement(elapTimeInputId, 'Minimum seconds between events:');\n\n    var inputContainer = document.querySelector('#' + TOLERANCE_TIME_DIV_ID);\n    inputContainer.appendChild(elapTimeLabel);\n    inputContainer.appendChild(elapTimeInput);\n\n    elapTimeInput.addEventListener('change', function (e) {\n      updateTrendChartSegments(parseInt(this.value));\n    });\n\n    function createNumberInput (id) {\n      var elapTimeInput = document.createElement('input');\n      elapTimeInput.setAttribute('id', id);\n      elapTimeInput.setAttribute('class', 'form-control');\n      elapTimeInput.setAttribute('type', 'number');\n      elapTimeInput.setAttribute('step', 10);\n      elapTimeInput.setAttribute('min', 0);\n      elapTimeInput.setAttribute('value', DEFAULT_SEGMENT_DISTANCE);\n      return elapTimeInput;\n    }\n  }\n\n  function createLabelElement (id, labelText, className) {\n    var labelEl = document.createElement('label');\n    labelEl.setAttribute('for', id);\n    labelEl.innerHTML = labelText;\n    if (className) {\n      labelEl.setAttribute('class', className);\n    }\n    return labelEl;\n  }\n\n  function updateTrendSegments (segmentDistance) {\n    segments = extractSegmentsFromTraceEvents(\n      userTraceLogs,\n      traceLogsInfo.get('actionD1').values.link,\n      traceLogsInfo.get('timestamp').initCol,\n      traceLogsInfo.get('actionD1').initCol,\n      segmentDistance || DEFAULT_SEGMENT_DISTANCE\n    );\n  }\n\n  function updateTrendChartSegments (segmentDistance) {\n    updateTrendSegments(segmentDistance);\n    updateTrendChartGrids();\n    changeDataOfTrendChart(null, function () {\n      trendsChart.flush();\n    });\n  }\n\n  function updateTrendChartGrids () {\n    trendsChart.xgrids.remove();\n    trendsChart.xgrids.add(parseUserTraceAsGridLines(segments));\n  }\n}());\n"},"./node_modules/script-loader/addScript.js":function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},"./src/scripts/index.js":function(e,n,t){t("./node_modules/script-loader/addScript.js")(t("./node_modules/raw-loader/index.js!./src/scripts/index.js"))}});